---
layout: default
---

<!-- 
  This file has been completely refactored based on your excellent UX feedback.
  - The layout starts as a single, focused reading column.
  - On the first chat interaction, it dynamically transitions to a two-column UI.
  - All styling has been moved to a dedicated /styles/research_post.css file.
-->

<div class="research-container" id="research-container">
    <div class="paper-column">
        <h1>{{ page.title }}</h1>
        <p><strong>Authors:</strong> {{ page.authors | join: ", " }}</p>
        <p><strong>PDF:</strong> <a href="{{ page.pdf }}" target="_blank">Download</a></p>
        <hr>
        <div id="paper-abstract">
            <h2>Abstract</h2>
            <p>{{ page.abstract }}</p>
        </div>
        <hr>
        <div class="paper-body" id="paper-content">
            {{ content }}
        </div>
    </div>

    <div class="chatbot-column loaded" id="chatbot-column">
        <h2>Ask anything about this paper</h2>
        <div id="chat-box">
            <div id="chat-log"></div>
            <input id="chat-input" type="text" placeholder="e.g., 'What were the key results?'">
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const researchContainer = document.getElementById('research-container');
    const chatbotColumn = document.getElementById('chatbot-column');
    const chatInput = document.getElementById('chat-input');
    const chatLog = document.getElementById('chat-log');
    const PROXY_URL = 'https://backe-nu.vercel.app/api/chat';

    let isChatActive = false;

    // --- Paper Content Caching (remains the same) ---
    const paperSections = {};
    paperSections['Abstract'] = document.getElementById('paper-abstract').innerText;
    const headings = [...document.querySelectorAll('.paper-body h2')];
    headings.forEach(heading => {
        const sectionName = heading.innerText.trim();
        let content = '';
        let nextElement = heading.nextElementSibling;
        while(nextElement && nextElement.tagName !== 'H2') {
            content += nextElement.innerText + '\n\n';
            nextElement = nextElement.nextElementSibling;
        }
        paperSections[sectionName] = content.trim();
    });
    paperSections['Full'] = document.getElementById('paper-content').innerText.slice(0, 15000);

    const sectionKeywords = {
        'Abstract': ['abstract', 'overview', 'tldr'],
        'Introduction': ['introduction', 'background', 'context', 'motivation'],
        'Methods': ['method', 'experiment', 'procedure', 'approach', 'technique', 'how'],
        'Results': ['result', 'finding', 'observation', 'data', 'what did they find'],
        'Conclusion': ['conclusion', 'takeaway', 'discussion', 'summarize', 'summary'],
    };

    const getSmartContext = (query, sectionContent) => {
        const stopWords = new Set(['a', 'an', 'the', 'is', 'in', 'on', 'of', 'for', 'to', 'what', 'did', 'they', 'how', 'were']);
        const queryKeywords = query.toLowerCase().split(/\s+/).filter(word => !stopWords.has(word) && word.length > 3);
        if (queryKeywords.length === 0) return sectionContent.slice(0, 4000);
        const paragraphs = sectionContent.split(/\n\s*\n/).filter(p => p.trim().length > 10);
        const relevantParagraphs = new Set();
        paragraphs.forEach(p => {
            for (const keyword of queryKeywords) {
                if (new RegExp(`\\b${keyword}\\b`, 'i').test(p)) {
                    relevantParagraphs.add(p);
                    break;
                }
            }
        });
        if (relevantParagraphs.size > 0) {
            return [...relevantParagraphs].join('\n\n');
        } else {
            return sectionContent.slice(0, 4000);
        }
    };

    // --- CORE CHAT LOGIC ---
    const handleUserQuery = async () => {
        const userInput = chatInput.value.trim();
        if (!userInput) return;

        // --- 1. DYNAMICALLY ACTIVATE CHAT UI (Your brilliant idea) ---
        if (!isChatActive) {
            researchContainer.classList.add('chatbot-active');
            isChatActive = true;
            // Small delay to allow CSS transition to start before scrolling
            setTimeout(() => chatLog.scrollTop = chatLog.scrollHeight, 100);
        }

        chatLog.innerHTML += `<p><strong>You:</strong> ${userInput}</p>`;
        chatInput.value = '';
        chatLog.scrollTop = chatLog.scrollHeight;
        
        chatLog.innerHTML += `<p><strong>Bot:</strong> Thinking...</p>`;
        setTimeout(() => { chatLog.scrollTop = chatLog.scrollHeight; }, 50);

        // --- 2. INTELLIGENT CONTEXT PIPELINE (The advanced logic) ---
        let bestSectionContent = paperSections['Full'];
        let detectedSection = 'Full';
        outerLoop: for (const [section, keywords] of Object.entries(sectionKeywords)) {
            for (const kw of keywords) {
                if (new RegExp(`\\b${kw}\\b`, 'i').test(userInput)) {
                    const actualSectionTitle = Object.keys(paperSections).find(h2 => new RegExp(section, 'i').test(h2));
                    if (actualSectionTitle && paperSections[actualSectionTitle]) {
                        bestSectionContent = paperSections[actualSectionTitle];
                        detectedSection = actualSectionTitle;
                        break outerLoop;
                    }
                }
            }
        }

        let contextToSend;
        if (detectedSection === 'Full' || detectedSection === 'Abstract' || /summary|summarize|overview/i.test(userInput)) {
            contextToSend = bestSectionContent;
        } else {
            contextToSend = getSmartContext(userInput, bestSectionContent);
        }

        // --- 3. API CALL (Serverless backend) ---
        try {
            const response = await fetch(PROXY_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ context: contextToSend.slice(0, 15000), message: userInput })
            });

            if (!response.ok) throw new Error(await response.text());

            const data = await response.json();
            const thinkingMessage = chatLog.querySelector('p:last-child');
            if (thinkingMessage) thinkingMessage.remove();

            if (data.response) {
                chatLog.innerHTML += `<p><strong>Bot:</strong> ${data.response}</p>`;
            } else {
                throw new Error("Invalid response from server.");
            }
        } catch (error) {
            console.error('Chatbot error:', error);
            const thinkingMessage = chatLog.querySelector('p:last-child');
            if (thinkingMessage) thinkingMessage.remove();
            chatLog.innerHTML += `<p><strong>Bot:</strong> An error occurred. Please check the console.</p>`;
        } finally {
            chatLog.scrollTop = chatLog.scrollHeight;
        }
    };

    chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            handleUserQuery();
        }
    });
});
</script>
